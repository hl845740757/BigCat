# Dson

## Dson是什么？

Dson是JSON和Bson的改进，其中‘D’的含义是‘Data’的意思，Dson是自解释的数据对象。  
设计Dson的主要目的是序列化，另一个目的是设计一套可转换为其它数据格式的中间层数据结构，
使得业务只需要编码为Dson，而不需要写更多的Codec，比如入库的Codec。

## 为什么创建Dson

在设计Dson之前，我也设计了序列化组件，也可以很好的工作；但最近在进行一些扩展的时候发现很难受，代码写得很不顺，思来想去，
发现是因为之前的Reader和Writer干的事情太多了，既在处理二进制的编码问题，又在处理业务层的复杂需求，如：读写替换、随机读。

简单说就是：**在二进制与Object之间少了一层中间层描述**。  
创建Dson之后，读对象需要两个Reader，写对象需要两个Writer，但代码变得清晰了，扩展性也更好了。

## Dson与Json和Bson

Json的数据格式是简单清晰的，但不是完全自解释的，即不能表达它是由什么数据序列化而来。
Bson在Json的基础之上进行了一定的改进，设计了值类型，生成的Json也是特殊的，在反序列化时能较Json更精确一些；
但这仍然不够，Bson的文档和Json的对象一样，不是自解释的（缺少自描述信息），因此在反序列化时无法精确解析，只能解析为Document。

对于Document，要实现精确的解析，我们可以在Document里存储一些特殊的数据以表达其类型 -- 轻度污染；
对于Array，则没有办法，因为在Array里插入额外数据是危险的，数组元素个数的改变是危险的 -- 重度污染。  
简单说，Json和Bson在设计之初并没有很好的考虑反序列化的问题，因此不适合做复杂情况下的序列化组件。

Dson为Array和Object设计了一个对象头，用于保存其类型信息，由于它是单独存储的，因此不会对数据造成污染。

阅读源码，大家会发现Dson的代码和MongoDB的Bson很像，这是因为我对MongoDB的Bson较为熟悉--前几年研究过Bson和Protobuf的编解码，
于是这两天写Dson的时候参考了Bson的代码，不过我们在许多地方的设计仍然是不同的，我相信你用Dson的Reader和Writer会更舒服。

## Dson与Protobuf

Q：为什么不使用Protobuf序列化？  
A：Protobuf是很好的序列化工具，但它也存在一些问题：

1. 必须定义Proto文件。
2. 不能序列化自定义类，必须定义Message，然后通过Builder进行构建。
3. 不支持多态 -- 我们只能先编码为bytes，封装一层。
4. 不支持继承。
5. 兼容性问题 -- Protobuf过于兼容了。

### 定义Proto文件

其实，对于一个跨语言的序列化工具来说，通过DSL文件描述数据结构是必须的，因此这个问题是个小问题；
不过在我们不需要跨语言的时候，维护proto文件就有点让人不爽。

### 自定义类问题

对于不能序列化自定义类这点，在java端是容易解决的，因为有注解。我们可以通过注解将一个类声明为需要按照Protobuf格式序列化，
然后静态或动态代码生成编解码代码；Protobuf的序列化格式是比较简单的，因此生成代码并不算复杂。

而对于不能通过工具解决的语言或项目，维护自定义类到Message之间的映射是痛苦的，这需要付出较多的维护成本。  
（当年既要写Message还要写MongoDB的Codec的日子真的痛苦...）

### 多态问题

Protobuf不支持多态，这也不算太大的问题。Protobuf不支持多态，是因为其需要定义schema，而schema要求一切都是明确的，明确的数据可以让编码结果更小。
我们在通过protobuf传输多态对象时，通常使用万能的bytes，将类型信息和对象一起放入bytes。

### 继承问题

继承其实是个小问题，因为传输的对象一般是简单的，对于存在继承的对象，我们通常展开为标签类，通过自定义type字段表明其类型。  
我在实现Dson的时候，发现继承确实会带来许多问题，但Dson是支持继承的，通常你不需要关注它。

### 兼容性问题

protobuf的数据非常兼容，以至于发生一些不期望的事情，这与protobuf的编码格式有关，pb的字段编码结果中只包含filedNumber和wireType，
即字段编号和编码格式，而**不包含字段的类型信息**，解码时完全按照接收方的schema进行解码，就可能胡乱解码，产生奇怪的兼容或异常。

不过，PB也正是能省则省才能够达到这么小的包体，在客户端与服务器通信时仍然是首选，在客户端服务器同步维护前，我们通常避免修改字段的类型。  
不过，也正是因为PB的这些问题，PB是不适合做持久化存储的 -- 个人认为用PB持久化（入库），等于给自己挖坑。

PS：DSON在序列化时仍然使用了Protobuf的组件，以压缩数字。

## 数据格式转换

### Dson如何实现到其它数据格式的转换
一般的序列化组件，只有简单int32、int64、string这种基本的值类型，通过这些值确实能构建任意的对象，但它们不能直接表达业务。
比如：一个类中的long字段是日期时间或时间戳，就无法在序列化结果中得到体现，因此也就无法直接转换为其它数据格式。
当然，你可以手写序列化代码，将这个long序列化为一个特定的数据结构，从而让序列化数据可以转换为其它数据格式。

Dson除了基本的值类型外，还提供了ExtInt32（带标签的Int32）、ExtInt64（带标签的Int64）、ExtString（带标签的String）-- 且Binary也是带标签的。
以上面的long值为例，用户可以通过注解将其标记为ExtInt64类型，并声明其子类型为datetime，生成的序列化代码就会将其序列化为ExtInt64,

简单说，Dson为用户提供大量的可选标签，尽量让序列化后的数据**记录字段的业务目的，而不仅仅是字段类型**，因此Dson的数据就更容易转换为其它数据格式。

### Dson为什么要做数据格式转换

在之前的序列化组件中，我也只设计了基本的数据类型，但我发现我写了Dson的Codec以后，假设想写入到MongoDB，多数情况下确实可以通过Dson转换，
但有一些特殊含义的字段，在转换时会出现异常，就比如上面的datetime，我真的不想写那么多的codec，于是就想让Dson来完成这件事。

## Dson的编码格式
